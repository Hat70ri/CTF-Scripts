#!/usr/bin/env python3
import math, random, time, base64, binascii, re

# ============================================================
# EDIT ONLY THIS SECTION
# ============================================================
N = 0
E = 0
C = 0

# Optional: add multiple challenges here to enable multi-NEC attacks
# NEC_LIST = [
#     (N1, E1, C1),
#     (N2, E2, C2),
# ]

FACTOR_TIMEBOX_SECONDS = 20      # Pollard Rho timebox
FERMAT_MAX_STEPS = 2_000_000     # Increase if you suspect p ~ q
WIENER_MAX_CONV = 20000          # Continued fraction depth limit
# ============================================================
# DO NOT EDIT BELOW
# ============================================================

# ---------- basic math ----------
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b % a, a)
    return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError(f"modular inverse does not exist (gcd={g})")
    return x % m

def int_to_bytes(x):
    if x == 0:
        return b"\x00"
    return x.to_bytes((x.bit_length() + 7) // 8, "big")

# ---------- integer root ----------
def iroot_k(n, k):
    if n < 0:
        raise ValueError("n must be non-negative")
    if n in (0, 1):
        return n
    low, high = 0, 1 << ((n.bit_length() + k - 1) // k)
    while low < high:
        mid = (low + high + 1) // 2
        if pow(mid, k) <= n:
            low = mid
        else:
            high = mid - 1
    return low

def try_no_wrap_root(N, e, c):
    m = iroot_k(c, e)
    return m if pow(m, e) == c else None

# ---------- decoding helpers ----------
def smart_print(m):
    b = int_to_bytes(m).lstrip(b"\x00")
    print("[p] m (int) :", m)
    print("[p] m (hex) :", hex(m))
    print("[p] bytes(hex):", b.hex())

    # 1) direct text
    s = b.decode(errors="replace")
    print("[p] text:", s)

    # 2) if looks like hex text, decode it
    if re.fullmatch(r"[0-9a-fA-F\s]+", s.strip()) and len(s.strip().replace(" ", "")) % 2 == 0:
        try:
            raw = bytes.fromhex(s.strip().replace(" ", ""))
            print("[p] hex-decoded:", raw.decode(errors="replace"))
        except Exception:
            pass

    # 3) if looks like base64, decode it
    st = s.strip()
    if len(st) >= 8 and all(ch in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r" for ch in st):
        try:
            raw = base64.b64decode(st, validate=False)
            if raw:
                print("[p] base64-decoded:", raw.decode(errors="replace"))
        except Exception:
            pass

# ---------- primality test ----------
def is_probable_prime(n):
    if n < 2:
        return False
    small = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small:
        if n == p:
            return True
        if n % p == 0:
            return False

    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x in (1, n-1):
            continue
        for _ in range(s-1):
            x = pow(x, 2, n)
            if x == n-1:
                break
        else:
            return False
    return True

# ---------- Fermat factoring (fast if p≈q) ----------
def fermat_factor(N, max_steps=FERMAT_MAX_STEPS):
    a = math.isqrt(N)
    if a * a < N:
        a += 1
    for _ in range(max_steps):
        b2 = a*a - N
        b = math.isqrt(b2)
        if b*b == b2:
            p = a - b
            q = a + b
            if p*q == N and p > 1 and q > 1:
                return (p, q) if p <= q else (q, p)
        a += 1
    return None

# ---------- Pollard Rho (Brent) ----------
def pollard_rho_brent(n, deadline):
    if n % 2 == 0:
        return 2
    if is_probable_prime(n):
        return n

    while time.time() < deadline:
        y = random.randrange(1, n - 1)
        c = random.randrange(1, n - 1)
        m = random.randrange(1, n - 1)
        g = r = q = 1

        def f(x): return (pow(x, 2, n) + c) % n

        while g == 1 and time.time() < deadline:
            x = y
            for _ in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1 and time.time() < deadline:
                ys = y
                for _ in range(min(m, r-k)):
                    y = f(y)
                    q = (q * abs(x - y)) % n
                g = math.gcd(q, n)
                k += m
            r *= 2

        if g == n:
            while time.time() < deadline:
                ys = f(ys)
                g = math.gcd(abs(x - ys), n)
                if g > 1:
                    break

        if 1 < g < n:
            return g
    return None

def try_factor(N, seconds=FACTOR_TIMEBOX_SECONDS):
    # small primes
    for p in [2,3,5,7,11,13,17,19,23,29,31,37]:
        if N % p == 0:
            return (p, N//p)
    # Fermat first (cheap + very effective when close primes)
    ff = fermat_factor(N)
    if ff:
        return ff
    # Pollard Rho timeboxed
    deadline = time.time() + max(1, seconds)
    f = pollard_rho_brent(N, deadline)
    if f and f != N:
        a, b = f, N//f
        return (a, b) if a <= b else (b, a)
    return None

# ---------- RSA decrypt from factors ----------
def rsa_decrypt_with_pq(N, e, c, p, q):
    phi = (p-1)*(q-1)
    if math.gcd(e, phi) != 1:
        raise ValueError(f"gcd(e,phi)={math.gcd(e,phi)} -> no unique inverse (weird RSA).")
    d = modinv(e, phi)
    return pow(c, d, N)

# ---------- Wiener attack (small d) ----------
def continued_fraction(n, d):
    cf = []
    while d:
        q = n // d
        cf.append(q)
        n, d = d, n - q*d
    return cf

def convergents(cf):
    p0, p1 = 0, 1
    q0, q1 = 1, 0
    for a in cf:
        p0, p1 = p1, a*p1 + p0
        q0, q1 = q1, a*q1 + q0
        yield p1, q1

def is_square(x):
    r = math.isqrt(x)
    return r*r == x

def wiener_attack(N, e):
    cf = continued_fraction(e, N)
    for i, (k, d) in enumerate(convergents(cf)):
        if i > WIENER_MAX_CONV:
            break
        if k == 0:
            continue
        # phi ≈ (ed - 1)/k
        if (e*d - 1) % k != 0:
            continue
        phi = (e*d - 1)//k
        # Solve for roots of x^2 - (N - phi + 1)x + N = 0
        s = N - phi + 1
        discr = s*s - 4*N
        if discr >= 0 and is_square(discr):
            t = math.isqrt(discr)
            p = (s - t)//2
            q = (s + t)//2
            if p*q == N and p > 1 and q > 1:
                return d, (p, q)
    return None

# ---------- multi-NEC helpers ----------
def shared_prime_attack(nec_list):
    Ns = [n for (n, e, c) in nec_list]
    for i in range(len(Ns)):
        for j in range(i+1, len(Ns)):
            g = math.gcd(Ns[i], Ns[j])
            if 1 < g < Ns[i]:
                return i, j, g
    return None

def main_single(N, E, C):
    print("\n=== Single NEC mode ===")
    print("[i] Trying no-wrap e-th root...")
    m = try_no_wrap_root(N, E, C)
    if m is not None:
        print("[+] Success: exact e-th root found.")
        smart_print(m)
        return True

    print("[i] Trying Wiener (small d) attack...")
    w = wiener_attack(N, E)
    if w:
        d, (p, q) = w
        print("[+] Wiener success: recovered d and factors.")
        m = pow(C, d, N)
        smart_print(m)
        return True
    print("[i] Wiener failed.")

    print("[i] Checking gcd(N, C) leak...")
    g = math.gcd(N, C)
    if 1 < g < N:
        p, q = g, N//g
        print("[+] gcd leak success.")
        m = rsa_decrypt_with_pq(N, E, C, p, q)
        smart_print(m)
        return True

    print("[i] Attempting factoring (Fermat then Pollard Rho timeboxed)...")
    fac = try_factor(N)
    if fac:
        p, q = fac
        print("[+] Factored N.")
        m = rsa_decrypt_with_pq(N, E, C, p, q)
        smart_print(m)
        return True

    print("[!] No solve with single-NEC attacks + timeboxed factoring.")
    print("    If the challenge says factoring isn’t an option, you likely need an oracle or extra leak not present in NEC alone.")
    return False

def main_multi(nec_list):
    print("\n=== Multi NEC mode ===")
    sp = shared_prime_attack(nec_list)
    if sp:
        i, j, p = sp
        print(f"[+] Shared prime found between entries {i} and {j}: p={p}")
        for idx, (N, E, C) in enumerate(nec_list):
            if N % p == 0:
                q = N // p
                try:
                    m = rsa_decrypt_with_pq(N, E, C, p, q)
                    print(f"\n--- Decrypted entry {idx} ---")
                    smart_print(m)
                except Exception as ex:
                    print(f"[!] Could not decrypt entry {idx}: {ex}")
        return True
    print("[i] No shared-prime gcd hits found.")
    return False

def main():
    if "NEC_LIST" in globals():
        nec_list = NEC_LIST
        if nec_list:
            solved_multi = main_multi(nec_list)
            if not solved_multi and len(nec_list) == 1:
                n,e,c = nec_list[0]
                main_single(n,e,c)
            elif not solved_multi:
                print("[i] Try adding more NECs or enable other multi-attacks (common modulus / Hastad) if applicable.")
            return

    if any(v == 0 for v in (N, E, C)):
        print("Paste N, E, C at the top (they are 0 right now).")
        return
    main_single(N, E, C)

if __name__ == "__main__":
    main()
